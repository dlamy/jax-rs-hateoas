package com.jayway.jaxrs.hateoas.core;

import static org.apache.commons.lang.Validate.*;

import java.lang.reflect.Constructor;
import java.util.Map;

import com.jayway.jaxrs.hateoas.CollectionWrapperStrategy;
import com.jayway.jaxrs.hateoas.HateoasLinkInjector;
import com.jayway.jaxrs.hateoas.HateoasVerbosity;
import com.jayway.jaxrs.hateoas.HateoasViewFactory;
import com.jayway.jaxrs.hateoas.support.DefaultCollectionWrapperStrategy;
import com.jayway.jaxrs.hateoas.support.DefaultHateoasViewFactory;
import com.jayway.jaxrs.hateoas.support.StrategyBasedLinkInjector;
import org.apache.commons.lang.BooleanUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * Helper factory to create Hateoas configuration classes
 *
 * @author Kalle Stenflo
 */
public class HateoasConfigurationFactory {

    private static final Logger logger = LoggerFactory.getLogger(HateoasConfigurationFactory.class);

    /**
     * If set this will determine the verbosity of the links generated by this
     * application
     * The instance may be a String that contains either one or more
     * names from the enum {@link com.jayway.jaxrs.hateoas.HateoasOption} class separated by ';', ','
     * or a single verbosity name defined in {@link com.jayway.jaxrs.hateoas.HateoasVerbosity}.
     *
     * @see com.jayway.jaxrs.hateoas.HateoasVerbosity
     * @see com.jayway.jaxrs.hateoas.HateoasOption
     */
    public static final String PROPERTY_HATEOAS_VERBOSITY = "com.jayway.jaxrs.hateoas.HateoasVerbosity";

    /**
     * If set specifies the implementation class of the {@link com.jayway.jaxrs.hateoas.HateoasLinkInjector}
     * The type of this property must be a String that is a Class name,
     * and the Class must a sub-class of
     * {@link com.jayway.jaxrs.hateoas.HateoasLinkInjector}.
     * If not set the default {@link com.jayway.jaxrs.hateoas.HateoasLinkInjector} implementation will be used.
     */
    public static final String PROPERTY_HATEOAS_LINK_INJECTOR = "com.jayway.jaxrs.hateoas.HateoasLinkInjector";

    /**
     * If set specifies the implementation class of the {@link com.jayway.jaxrs.hateoas.CollectionWrapperStrategy}
     * The type of this property must be a String that is a Class name,
     * and the Class must a sub-class of
     * {@link com.jayway.jaxrs.hateoas.CollectionWrapperStrategy}.
     * If not set the default {@link com.jayway.jaxrs.hateoas.CollectionWrapperStrategy} implementation will be used.
     */
    public static final String PROPERTY_HATEOAS_COLLECTION_WRAPPER_STRATEGY = "com.jayway.jaxrs.hateoas.CollectionWrapperStrategy";

    /**
     * If set specifies the implementation class of the {@link com.jayway.jaxrs.hateoas.HateoasViewFactory}
     * The type of this property must be a String that is a Class name,
     * and the Class must a implement  {@link com.jayway.jaxrs.hateoas.HateoasViewFactory}.
     * If not set the default {@link com.jayway.jaxrs.hateoas.HateoasViewFactory} implementation will be used. Note that this
     * implementation will not produce a view, only return the model provided.
     */
    public static final String PROPERTY_HATEOAS_VIEW_FACTORY = "com.jayway.jaxrs.hateoas.HateoasViewFactory";

    /**
     * If set specifies the way in which links are structured in JSON:  as a Collection (JSON Array) or as a Map (JSON Object).
     * The "rel" value is used as the map key, and the rel entry is removed from the link information set.
     * The type of this property must be a String that is either "true" or "false".  If true, links are output as a JSON Object.
     * Otherwise, links are output as a JSON Array.
     * If not set the default value is "false".
     */
    public static final String PROPERTY_HATEOAS_MAP_STRUCTURE_ENABLED = "com.jayway.jaxrs.hateoas.HateorasMapStructureEnabled";


    @SuppressWarnings("unchecked")
    public static HateoasViewFactory createHateoasViewFactory(Map<String, Object> props, String... defaults) {
        String implClass = getProperty(props, PROPERTY_HATEOAS_VIEW_FACTORY, DefaultHateoasViewFactory.class.getName(), defaults);
        try {
            return (HateoasViewFactory) Class.forName((String) implClass).newInstance();
        }
        catch (Exception e) {
            throw new RuntimeException("Failed to instantiate " + implClass);
        }
    }


    @SuppressWarnings("unchecked")
    public static HateoasLinkInjector<Object> createLinkInjector(Map<String, Object> props, String... defaults) {
        String implClass = getProperty(props, PROPERTY_HATEOAS_LINK_INJECTOR, StrategyBasedLinkInjector.class.getName(), defaults);

        try {
            Class<HateoasLinkInjector<Object>> clazz = (Class<HateoasLinkInjector<Object>>) Class.forName((String) implClass);

            // if the HateoasLinkInjector implementation has a boolean constructor, take it assuming that it is accepting
            // the mapEnabled parameter
            try {
                Constructor<HateoasLinkInjector<Object>> ctor = clazz.getConstructor(boolean.class);
                String mapEnabledStr = getProperty(props, PROPERTY_HATEOAS_MAP_STRUCTURE_ENABLED, "false", defaults);
                boolean mapEnabled = BooleanUtils.toBoolean(mapEnabledStr);
                return ctor.newInstance(mapEnabled);
            }
            catch (Exception ex) {
                return clazz.newInstance();
            }
        }
        catch (Exception e) {
            throw new RuntimeException("Failed to instantiate " + implClass);
        }
    }

    @SuppressWarnings("unchecked")
    public static CollectionWrapperStrategy createCollectionWrapperStrategy(Map<String, Object> props, String... defaults) {
        String implClass = getProperty(props, PROPERTY_HATEOAS_COLLECTION_WRAPPER_STRATEGY, DefaultCollectionWrapperStrategy.class.getName(), defaults);
        try {
            return (CollectionWrapperStrategy) Class.forName((String) implClass).newInstance();
        }
        catch (Exception e) {
            throw new RuntimeException("Failed to instantiate " + implClass);
        }
    }

    public static HateoasVerbosity createVerbosity(Map<String, Object> props, String... defaults) {
        String verbosityConfig = getProperty(props, PROPERTY_HATEOAS_VERBOSITY, "MAXIMUM", defaults);
        HateoasVerbosity verbosity = HateoasVerbosity.findByName(verbosityConfig);
        if (verbosity != null) {
            return verbosity;
        }
        return HateoasVerbosity.valueOf(verbosityConfig);
    }


    private static String getProperty(Map<String, Object> props, String property, String systemDefault, String... defaults) {
        notEmpty(property, "property must not be null or empty.");
        String propertyValue = (String) props.get(property);
        if (propertyValue == null || propertyValue.trim().isEmpty()) {
            if (defaults != null && defaults.length > 0) {
                propertyValue = defaults[0];
            }
            else {
                propertyValue = systemDefault;
            }
        }
        return propertyValue;
    }
}
